#  Copyright 2023-2024 Dataport AÃ¶R
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

diff --git a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/LocalSignatureVerifier.java b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/LocalSignatureVerifier.java
index c9aa361a..8d7efab2 100644
--- a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/LocalSignatureVerifier.java
+++ b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/LocalSignatureVerifier.java
@@ -13,6 +13,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import com.danubetech.verifiablecredentials.CredentialSubject;
 import org.apache.commons.io.IOUtils;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
 
@@ -89,6 +90,12 @@ public class LocalSignatureVerifier implements SignatureVerifier {
 	@Override
 	public boolean verify(JsonLDObject payload, LdProof proof, JWK jwk, String alg) {
       log.debug("verify; got jwk: {}, alg: {}", jwk, alg);
+
+	  if (isPureComplianceCredential(payload) || isPureRegistrationNumberCredential(payload)) {
+		  log.info("received proof from compliance credential subject, ignoring signature...");
+		  return true;
+	  }
+
 	  PublicKeyVerifier<?> pkVerifier = PublicKeyVerifierFactory.publicKeyVerifierForJWK(jwk, alg);
 	  LdVerifier<?> verifier = new JsonWebSignature2020LdVerifier(pkVerifier);
 	  try {
diff --git a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/SignatureVerifier.java b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/SignatureVerifier.java
index c973ba08..d1ce4473 100644
--- a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/SignatureVerifier.java
+++ b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/SignatureVerifier.java
@@ -3,13 +3,46 @@ package eu.xfsc.fc.core.service.verification.signature;
 
 import com.danubetech.keyformats.jose.JWK;
 
+import com.danubetech.verifiablecredentials.CredentialSubject;
 import eu.xfsc.fc.core.pojo.Validator;
 import foundation.identity.jsonld.JsonLDObject;
 import info.weboftrust.ldsignatures.LdProof;
 
+import java.util.List;
+import java.util.Map;
+
 public interface SignatureVerifier {
 
 	  Validator checkSignature(JsonLDObject payload, LdProof proof);
 	  boolean verify(JsonLDObject payload, LdProof proof, JWK jwk, String alg);
-	
+
+	  default boolean isPureCredential(JsonLDObject payload, String type) {
+		  Object csObject = payload.getJsonObject().get("credentialSubject");
+		  if (csObject instanceof List<?> csObjectList) {
+			  // if credential subject is a list, check every element for type
+			  List<CredentialSubject> csList = csObjectList.stream()
+					  .filter(o -> o instanceof Map<?, ?>)
+					  .map(o -> (Map<String, Object>) o)
+					  .map(CredentialSubject::fromMap)
+					  .toList();
+			  boolean allCompliance = !csList.isEmpty();
+			  for (CredentialSubject innerCs : csList) {
+				  allCompliance &= innerCs.isType(type);
+			  }
+			  return allCompliance;
+		  } else if (csObject instanceof Map<?, ?> csObjectMap) {
+			  // if credential subject is not a list, it is a plain object. check type
+			  CredentialSubject cs = CredentialSubject.fromMap((Map<String, Object>) csObjectMap);
+			  return cs.isType(type);
+		  } else {
+			  return false;
+		  }
+	  }
+	  default boolean isPureComplianceCredential(JsonLDObject payload) {
+		  return isPureCredential(payload, "gx:compliance");
+	  }
+
+	default boolean isPureRegistrationNumberCredential(JsonLDObject payload) {
+		return isPureCredential(payload, "gx:legalRegistrationNumber");
+	}
 }
diff --git a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/UniSignatureVerifier.java b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/UniSignatureVerifier.java
index f752f523..01843439 100644
--- a/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/UniSignatureVerifier.java
+++ b/fc-service-core/src/main/java/eu/xfsc/fc/core/service/verification/signature/UniSignatureVerifier.java
@@ -8,6 +8,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 
+import com.danubetech.verifiablecredentials.CredentialSubject;
 import org.springframework.beans.factory.annotation.Autowired;
 
 import com.danubetech.keyformats.crypto.PublicKeyVerifier;
@@ -92,6 +93,12 @@ public class UniSignatureVerifier implements SignatureVerifier {
 	@Override
 	public boolean verify(JsonLDObject payload, LdProof proof, JWK jwk, String alg) {
 		log.debug("verify.enter; alg: {}, jwk: {}", alg, jwk);
+
+		if (isPureComplianceCredential(payload) || isPureRegistrationNumberCredential(payload)) {
+			log.info("received proof from compliance credential subject, ignoring signature...");
+			return true;
+		}
+
 		LdVerifier<?> verifier = LdVerifierRegistry.getLdVerifierBySignatureSuiteTerm(proof.getType());
 		PublicKeyVerifier<?> pkVerifier = PublicKeyVerifierFactory.publicKeyVerifierForJWK(jwk, alg);
 		verifier.setVerifier(pkVerifier);
